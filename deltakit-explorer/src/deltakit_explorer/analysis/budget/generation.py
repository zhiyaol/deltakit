import itertools
from collections.abc import Sequence
from concurrent.futures import ProcessPoolExecutor
from typing import Mapping, Type

import numpy
import numpy.typing as npt
from deltakit_circuit.gates._abstract_gates import PauliBasis
from deltakit_decode._mwpm_decoder import PyMatchingDecoder
from deltakit_decode.analysis._matching_decoder_managers import StimDecoderManager
from tqdm import tqdm

from deltakit_explorer.analysis.budget.interfaces import NoiseInterface
from deltakit_explorer.codes._css._css_code_experiment_circuit import (
    css_code_memory_circuit,
)
from deltakit_explorer.codes._planar_code._rotated_planar_code import RotatedPlanarCode


def _generate_surface_code_memory_decoder_manager(
    distance: int,
    num_rounds: int,
    noise_model: NoiseInterface,
) -> StimDecoderManager | None:
    """Generate a decoder manager with a rotated planar code memory experiment.

    Args:
        distance (int): distance of the rotated planar code memory experiment that
            should be generated by this function.
        num_rounds (int): number of stabilizer measurement rounds of the memory
            experiment generated by this function.
        noise_model (NoiseInterface): noise model that should be applied to the
            noiseless memory experiment generated within this function.

    Returns:
        a decoder manager that can then be run using ``RunAllAnalysisEngine`` or
        ``None`` if the problem is ill-formed.
    """
    circuit = css_code_memory_circuit(
        RotatedPlanarCode(distance, distance), num_rounds, PauliBasis.Z
    )
    noisy_circuit = noise_model.apply(circuit)
    decoder, decoder_circuit = PyMatchingDecoder.construct_decoder_and_stim_circuit(
        noisy_circuit
    )
    metadata = {
        "distance": distance,
        "num_rounds": num_rounds,
        "noise_parameters": noise_model.noise_parameters,
    }

    return StimDecoderManager(decoder_circuit, decoder, metadata=metadata)  # type: ignore


def _generate_surface_code_memory_decoder_manager_from_h_wrapper(
    data: tuple[int, int, NoiseInterface, int, tuple[int, float]],
) -> StimDecoderManager | None:
    d, nr, nm, mh, (npi, h) = data
    # Early exit if the provided noise parameters are invalid.
    if not nm.is_variation_on_parameter_valid(npi, mh * h):
        return None
    noise_model = nm.variate_noise_parameter_by(npi, mh * h)
    return _generate_surface_code_memory_decoder_manager(d, nr, noise_model)


def _generate_surface_code_memory_decoder_manager_wrapper(
    data: tuple[int, int, NoiseInterface],
) -> StimDecoderManager | None:
    return _generate_surface_code_memory_decoder_manager(*data)


def generate_decoder_managers_for_lambda(
    xi: npt.NDArray[numpy.float64],
    noise_model_type: Type[NoiseInterface],
    num_rounds_by_distances: Mapping[int, Sequence[int]],
    max_workers: int = 1,
) -> list[StimDecoderManager]:
    """Generate several decoder managers from the provided arguments for a rotated
    planar code memory experiment.

    This function should be used to generate in one call a description of all the
    sampling tasks that should be done in order to estimate the value of Λ on the
    provided noise parameters ``xi``.

    Note:
        Generating the tasks might be a long process, hence the presence of the
        ``max_worker`` parameter.

    Warning:
        This function will generate ``len(num_rounds) * len(distances) *
        numpy.prod(xi.shape[1:])`` sampling tasks. That quantity
        might grow quickly, so try to avoid providing too many entries in ``distances``
        and ``num_rounds`` except if you really need it.

    Args:
        xi (npt.NDArray[numpy.float64]): an array of shape ``(m, n)``, where ``m`` is
            the number of noise parameters needed by ``noise_model_type`` and ``n`` the
            number of points to evaluate Λ on.
        noise_model_type (Type[NoiseInterface]): noise model that should be applied to
            the noiseless memory experiments generated within this function.
        num_rounds_by_distances (Mapping[int, Sequence[int]]): the different number of
            rounds that will be used to estimate the logical error-rate per round for
            each code distance. As a rule of thumb, at least ``4`` entries should be
            provided and the maximum number of rounds should, if possible, give a
            logical error-rate above ``0.2`` for the largest distance and a logical
            error-rate below ``0.45`` for the smallest distance. You will not be able to
            check those thresholds everytime, but the standard errors computed will be
            lower if they are verified.
        max_workers (int): if provided, the number of parallel processes that are used
            to generate the sampling tasks. If not, default to ``1``.

    Returns:
        a list of decoder managers that can then be run using ``RunAllAnalysisEngine``.
    """
    # 0. Transposing to be able to iterate on different values.
    xi = xi.T
    # 1. Check input parameters
    for x in xi:
        if (message := noise_model_type.is_valid(x)) is not None:
            parameters = "[" + ", ".join(f"{float(v):.3g}" for v in x) + "]"
            raise ValueError(
                f"The provided parameters {parameters} are invalid for noise model "
                f"{noise_model_type.__name__}. Reason is: '{message}'."
            )
    if max_workers <= 0:
        raise ValueError(
            f"Cannot have less than one worker. Asked for {max_workers} workers."
        )
    # 2. Generate the decoder managers
    decoder_managers: list[StimDecoderManager] = []
    total_circuits = (
        sum(len(nrounds) for nrounds in num_rounds_by_distances.values()) * xi.shape[0]
    )
    distance_and_rounds_iterator = itertools.chain.from_iterable(
        zip(itertools.repeat(d, len(rounds)), rounds, strict=True)
        for d, rounds in num_rounds_by_distances.items()
    )
    parameters_iterator = (
        (d, nr, nm)
        for (d, nr), nm in itertools.product(
            distance_and_rounds_iterator, (noise_model_type(x) for x in xi)
        )
    )
    if max_workers == 1:
        for distance, nrounds, noise_model in parameters_iterator:
            manager = _generate_surface_code_memory_decoder_manager(
                distance, nrounds, noise_model
            )
            assert manager is not None
            decoder_managers.append(manager)
        return decoder_managers
    # Else, we might use several workers
    with ProcessPoolExecutor(max_workers=max_workers) as pool:
        for manager in tqdm(
            iterable=pool.map(
                _generate_surface_code_memory_decoder_manager_wrapper,
                parameters_iterator,
            ),
            total=total_circuits,
            desc="Generating quantum circuits",
        ):
            assert manager is not None
            decoder_managers.append(manager)
        return decoder_managers
